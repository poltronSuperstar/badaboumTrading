/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RootFolderContextMenu
});
module.exports = __toCommonJS(main_exports);

// src/RootFolderContextMenuPlugin.ts
var import_obsidian = require("obsidian");

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/Async.ts
var RETRY_DELAY_IN_MILLISECONDS = 100;
var TIMEOUT_IN_MILLISECONDS = 5e3;
async function delay(milliseconds) {
  await new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function runWithTimeout(timeoutInMilliseconds, asyncFn) {
  return await Promise.race([asyncFn(), timeout()]);
  async function timeout() {
    await delay(timeoutInMilliseconds);
    throw new Error(`Timed out in ${timeoutInMilliseconds} milliseconds`);
  }
}
async function retryWithTimeout(asyncFn, options = {
  timeoutInMilliseconds: TIMEOUT_IN_MILLISECONDS,
  retryDelayInMilliseconds: RETRY_DELAY_IN_MILLISECONDS
}) {
  await runWithTimeout(options.timeoutInMilliseconds, async () => {
    while (true) {
      if (await asyncFn()) {
        console.debug("Retry completed successfully");
        return;
      }
      console.debug(`Retry completed unsuccessfully. Trying again in ${options.retryDelayInMilliseconds} milliseconds`);
      await delay(options.retryDelayInMilliseconds);
    }
  });
}

// src/Object.ts
function getPrototypeOf(instance) {
  return Object.getPrototypeOf(instance);
}

// ../obsidian-typings/index.ts
var InternalPluginName = {
  AudioRecorder: "audio-recorder",
  Backlink: "backlink",
  Bookmarks: "bookmarks",
  Canvas: "canvas",
  CommandPalette: "command-palette",
  DailyNotes: "daily-notes",
  EditorStatus: "editor-status",
  FileExplorer: "file-explorer",
  FileRecovery: "file-recovery",
  GlobalSearch: "global-search",
  Graph: "graph",
  MarkdownImporter: "markdown-importer",
  NoteComposer: "note-composer",
  OutgoingLink: "outgoing-link",
  Outline: "outline",
  PagePreview: "page-preview",
  Properties: "properties",
  Publish: "publish",
  RandomNote: "random-note",
  SlashCommand: "slash-command",
  Slides: "slides",
  Starred: "starred",
  Switcher: "switcher",
  Sync: "sync",
  TagPane: "tag-pane",
  Templates: "templates",
  WordCount: "word-count",
  Workspaces: "workspaces",
  ZkPrefixer: "zk-prefixer"
};

// src/RootFolderContextMenuPlugin.ts
var RootFolderContextMenu = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "fileExplorerPlugin");
    __publicField(this, "fileExplorerView");
  }
  onload() {
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  async onLayoutReady() {
    const fileExplorerPluginInstance = this.app.internalPlugins.getEnabledPluginById(InternalPluginName.FileExplorer);
    if (!fileExplorerPluginInstance) {
      await this.disablePlugin("File Explorer plugin is disabled. Disabling the plugin...");
      return;
    }
    this.fileExplorerPlugin = fileExplorerPluginInstance.plugin;
    await this.initFileExplorerView();
    const viewPrototype = getPrototypeOf(this.fileExplorerView);
    const removeFileExplorerViewPatch = around(viewPrototype, {
      openFileContextMenu: this.applyOpenFileContextMenuPatch.bind(this)
    });
    this.register(removeFileExplorerViewPatch);
    this.register(this.reloadFileExplorer.bind(this));
    await this.reloadFileExplorer();
    const vaultSwitcherEl = document.querySelector(".workspace-drawer-vault-switcher");
    if (vaultSwitcherEl) {
      this.fileExplorerView.files.set(vaultSwitcherEl, this.app.vault.getRoot());
      this.registerDomEvent(vaultSwitcherEl, "contextmenu", async (ev) => {
        await delay(RETRY_DELAY_IN_MILLISECONDS);
        document.body.click();
        this.fileExplorerView.openFileContextMenu(ev, vaultSwitcherEl.childNodes[0]);
      });
    }
  }
  applyOpenFileContextMenuPatch(next) {
    return function(event, fileItemElement) {
      const file = this.files.get(fileItemElement.parentElement);
      if (!(file instanceof import_obsidian.TFolder) || !file.isRoot()) {
        next.call(this, event, fileItemElement);
        return;
      }
      file.isRoot = () => false;
      next.call(this, event, fileItemElement);
      file.isRoot = () => true;
    };
  }
  async reloadFileExplorer() {
    console.log("Disabling File Explorer plugin");
    this.fileExplorerPlugin.disable();
    console.log("Enabling File Explorer plugin");
    await this.fileExplorerPlugin.enable();
    await this.initFileExplorerView();
  }
  async initFileExplorerView() {
    try {
      await retryWithTimeout(() => {
        const fileExplorerLeaf = this.app.workspace.getLeavesOfType(InternalPluginName.FileExplorer)[0];
        if (fileExplorerLeaf) {
          console.debug("FileExplorerLeaf is initialized");
          this.fileExplorerView = fileExplorerLeaf.view;
          return true;
        }
        console.debug("FileExplorerLeaf is not initialized yet. Repeating...");
        return false;
      });
    } catch (e) {
      console.error(e);
      await this.disablePlugin("Could not initialize FileExplorerView. Disabling the plugin...");
    }
  }
  async disablePlugin(message) {
    console.error(message);
    new import_obsidian.Notice(message);
    await this.app.plugins.disablePlugin(this.manifest.id);
  }
};
